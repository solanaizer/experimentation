code_snippet,description,mitigation
"pub mod signer_authorization_insecure { use super::*; pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult { msg!(""GM {}"", ctx.accounts.authority.key().to_string()); Ok(()) } } #[derive(Accounts)] pub struct LogMessage<'info> { authority: AccountInfo<'info>, }",The account is missing signer check,"#[program] pub mod signer_authorization_recommended { use super::*; pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult { msg!(""GM {}"", ctx.accounts.authority.key().to_string()); Ok(()) } } #[derive(Accounts)] pub struct LogMessage<'info> { authority: Signer<'info>, }"
"#[program] pub mod owner_checks_insecure { use super::*; pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult { let token = SplTokenAccount::unpack(&ctx.accounts.token.data.borrow())?; if ctx.accounts.authority.key != &token.owner { return Err(ProgramError::InvalidAccountData); } msg!(""Your account balance is: {}"", token.amount); Ok(()) } } #[derive(Accounts)] pub struct LogMessage<'info> { token: AccountInfo<'info>, authority: Signer<'info>, }",MissingOwnerCheck,"#[program] pub mod owner_checks_recommended { use super::*; pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult { msg!(""Your account balance is: {}"", ctx.accounts.token.amount); Ok(()) } } #[derive(Accounts)] pub struct LogMessage<'info> { #[account(constraint = authority.key == &token.owner)] token: Account<'info, TokenAccount>, authority: Signer<'info>, }"
